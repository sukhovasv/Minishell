#include "../include/minishell.h"

/*
Функция handle_signals
Проверяем, если сигнал равен SIGINT (ctrl + c),
write(1, "\n", 1) вручную выводит символ новой строки в стандартный вывод (stdout),
чтобы курсор переместился на новую строку после получения сигнала.
rl_on_new_line() уведомляет систему, что начинается ввод новой строки.
Устанавливает внутреннее состояние библиотеки readline для подготовки
к отображению нового приглашения и обработки ввода с новой строки.
rl_replace_line("", 0) заменяет текущую строку ввода пустой строкой.
Очищает текущей строки ввода, удаляет все символы, которые могли
быть введены до нажатия Ctrl+C (на маке нет этой функции, не нашла альтернативу, на linux
работает)
rl_redisplay() перерисовывает строку ввода, обновляя отображение
приглашения и текущей строки.

Функция setup_signals настраивает обработчики сигналов (SIGINT и SIGQUIT
в нашем случае).
struct sigaction sa структура sigaction, которая будет
использоваться для указания, как программа должна обрабатывать сигнал SIGINT
Структура содержит информацию об обработчике сигнала, маске сигналов и флагах
которые будут применяться при обработке сигналов.

sa.sa_handler = &handle_signals
Эта строка устанавливает поле sa_handler структуры sigaction, указывая на
функцию handle_signals. Это означает, что при получении сигнала SIGINT
будет вызвана функция handle_signals

sa.sa_flags = SA_RESTART
Этот флаг гарантирует, что если обработчик сигнала
прервет выполнение некоторых системных вызовов (таких как read или write),
они будут автоматически перезапущены вместо того, чтобы завершиться с ошибкой.

sigemptyset(&sa.sa_mask)
Эта функция инициализирует поле sa_mask структуры
sigaction пустым набором. Это означает, что во время выполнения обработчика
сигнала не будут блокироваться никакие дополнительные сигналы.

sigaction(SIGINT, &sa, NULL)
Этот системный вызов применяет настройки
sigaction для сигнала SIGINT. Он говорит операционной системе, что для
обработки сигналов SIGINT нужно использовать функцию handle_signals

signal(SIGQUIT, SIG_IGN)
Эта строка устанавливает обработчик сигнала SIGQUIT
(Ctrl + \) на SIG_IGN (игнорировать).
Т.е. при нажатии Ctrl + \ ничего не произойдёт, и программа продолжит
работу как обычно
*/

void handle_signals(int sig)
{
    if (sig == SIGINT)
    {
        write(1, "\n", 1);
        rl_on_new_line();
        rl_replace_line("", 0);
        rl_redisplay();
    }
}

void setup_signals(void)
{
    struct sigaction sa;

    sa.sa_handler = &handle_signals;
    sa.sa_flags = SA_RESTART;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, NULL);
    signal(SIGQUIT, SIG_IGN);
}